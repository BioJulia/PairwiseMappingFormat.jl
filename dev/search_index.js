var documenterSearchIndex = {"docs":
[{"location":"#PairwiseMappingFormat.jl","page":"Home","title":"PairwiseMappingFormat.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This package is for reading files of the PAF (Pairwise mApping Format) format, which is a simple tab-delimited format used by e.g. minimap2 and strobealign to store records representing pairwise alignment between biological sequences.","category":"page"},{"location":"#Reader","page":"Home","title":"Reader","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The PAFReader type wraps an IO, and is an iterator of PAFRecord objects:","category":"page"},{"location":"","page":"Home","title":"Home","text":"reader = PAFReader(open(path_to_paf))\nrecords = collect(reader)\nclose(reader)\n\n@assert isempty(reader)\n@assert typeof(records) == Vector{PAFRecord}","category":"page"},{"location":"","page":"Home","title":"Home","text":"Similar to the common open(path) do io-syntax in Julia, PAFReader takes an optional f::Function as a first argument, in which case it will apply f to the returned PAFReader object, and close the underlying io when f returns (or errors):","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> PAFReader(open(path_to_paf)) do reader\n           for record in reader\n               println(record.qlen)\n           end\n       end\n301156\n299273\n288659","category":"page"},{"location":"","page":"Home","title":"Home","text":"The PAFReader constructor takes an optional keyword copy, which defaults to true. If it is false, the record will iterate the same PAFRecord object, overwriting it in-place. This reduces allocations and gives a slight speed increase, but may result in bugs if records, or references of records of previous iterations are stored and unexpectedly overwritten:","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> records = PAFReader(collect, open(path_to_paf); copy=false);\n\njulia> println(map(i -> i.qlen, records)) # NB: All the same record!\n[288659, 288659, 288659]","category":"page"},{"location":"","page":"Home","title":"Home","text":"At the moments, readers do not support seeking.","category":"page"},{"location":"#Record","page":"Home","title":"Record","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The mutable PAFRecord object represents a single line in a PAF file. The individual columns of the PAF line is obtained by accessing properties of the records:","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> record = PAFReader(first, open(path_to_paf));\n\njulia> println(record.qname)\nquery1\n\njulia> println(record.qlen)\n301156\n\njulia> println(record.mapq)\n0","category":"page"},{"location":"","page":"Home","title":"Home","text":"Note that Base.getproperty is overloaded for PAFRecord, so the properties are public and stable across major versions, but may not reflect the actual underlying fields as they are stored in the PAFRecord.","category":"page"},{"location":"#Fields-of-PAFRecord","page":"Home","title":"Fields of PAFRecord","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"qname::StringView{A}. A is an implementation detail. Names of the query sequences When the sequences are from a FASTA file, this is typically the identifier of the FASTA records, i.e. the part of the header before the first space.\ntname::Union{Nothing, StringView{A}}. Same as qname, but for the target (i.e. subject) sequence. May be nothing if the record is unmapped.\nqlen and tlen. Of type Int. Length of the full query and target sequence.\nqstart and tstart. Of type Int. Leftmost (i.e. lowest) position of the alignment in the query and target, respectively. This does not take strandedness into account.\nqend and tend. Of type Int. Rightmost (i.e. highest) position of the alignment in the query and target, respectively. This does not take strandedness into account. As such, we always have record.qend - record.qtart) >= 0, and likewise for the target.\nalnlen::Int. Length of alignment. That includes gaps in query and target, and may therefore not match either qend - qstart + 1, or that of the target.\nmatches::Int. Number of residue matches (not mismatches) in the alignment. matches / alnlen is the alignment identity and is between 0 and 1.\nmapq::Union{Int, Nothing}. Mapping quality, from 0:254, where 254 is the better quality. When calibrated, the probability the mapping is correct should be 10^(-mapq / 10). A value of nothing indicates the mapping quality is unavailable.\nis_rc::Union{Bool, Nothing} indicates whether the alignment matches the target on the forward (false) or reverse-complement true strand. A missing alignment is nothing.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The PAF format does not contain fields for alignment identity, query coverage or target coverage. However, these can be approximated with the functions aln_identity, query_coverage and query_coverage.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Besides being iterated from PAFReader, records can also be created by parsing from a bytes-like object such as a String:","category":"page"},{"location":"","page":"Home","title":"Home","text":"data = \"contig_11\\t288659\\t27\\t288653\\t+\\tCP004047.1\\t6701780\\t5027225\\t5315851\\t288618\\t288626\\t0\\ttp:A:P\\tcm:i:28871\\ts1:i:288618\\ts2:i:288618\\tdv:f:0.0000\\trl:i:57\"\n\nrecord = parse(PAFRecord, data)\n@assert record isa PAFRecord","category":"page"},{"location":"","page":"Home","title":"Home","text":"Rarely, PAF records are unmapped. An unmapped record contain the query id, the query length, and any auxiliary fields. The target name and the strand of an unmapped return is nothing. You can check if a record is mapped or unmapped with the function is_mapped:","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> unmapped = parse(PAFRecord, \"myquery\\t5032251\\t9\\t11\\t*\\t*\\t5\\t2\\t1\\t7\\t4\\t0\");\n\njulia> @assert !is_mapped(unmapped)\n\njulia> println(unmapped.qname)\nmyquery\n\njulia> println(unmapped.qlen)\n5032251\n\njulia> @assert isnothing(unmapped.tname)\n\njulia> # The strand is given by is_rc, and is nothing for unmapped records\n       @assert isnothing(unmapped.is_rc)","category":"page"},{"location":"","page":"Home","title":"Home","text":"All other properties of unmapped records may contain arbitrary data, and should not be relied on. For this reason, the functions target_coverage, query_coverage and aln_identity may give nonsense answers for unmapped records:","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> # Note! These results are arbitrary and not guaranteed to be stable\n       # across minor releases of this package\n       println(target_coverage(unmapped))\nInf\n\njulia> println(query_coverage(unmapped))\n1.9871822768776836e-7\n\njulia> println(aln_identity(unmapped))\nNaN","category":"page"},{"location":"#Low-level-interface","page":"Home","title":"Low-level interface","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Iterating PAFReaders, and the parse function will throw a PairwiseMappingFormat.ParserException if the data is invalid:","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> parse(PAFRecord, \"not a PAF line\")\nERROR: Error when parsing PAF record on line 1, near byte number 14 in line: Not enough tab-separated fields. Each line must have at least 12 fields\n[...]","category":"page"},{"location":"","page":"Home","title":"Home","text":"In some circuomstances, throwing exceptions may not be acceptable, and so PairwiseMappingFormat.jl provide functionality for returning errors as values. These values can then be checked to programmatically handle error states.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The public, unexported try_parse function can be used instead of Base.parse. It either returns a valid PAFRecord, or else returns the ParserException, but does not throw the exception:","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> const PAF = PairwiseMappingFormat;\n\njulia> println(PAF.try_parse(\"not a PAF line\"))\nPairwiseMappingFormat.ParserException(PairwiseMappingFormat.Errors.TooFewFields, 14, 1)","category":"page"},{"location":"","page":"Home","title":"Home","text":"Similarly, the next record of a PAFReader may be obtained with the unexported try_next! function. This function will either:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Return nothing if the reader has no more records\nReturn a ParserException if the next record is invalid\nReturn a PAFRecord if there is another valid record. Only in this case it will advance the position of the reader.","category":"page"},{"location":"","page":"Home","title":"Home","text":"In other words, if a call to try_next! returns nothing or a ParserException, any future calls will return the same value forever:","category":"page"},{"location":"","page":"Home","title":"Home","text":"reader = PAFReader(open(path_to_paf))\n\n# Emits `PAFRecord` for valid records\nrecords = [try_next!(reader) for i in 1:3]\n@assert records isa Vector{PAFRecord}\n\n# Indefinitely emits `nothing` once the reader is empty\nnothings = [try_next!(reader) for i in 1:10]\n@assert nothings isa Vector{Nothing}\n\nclose(reader)\n\nreader = PAFReader(IOBuffer(\"not a PAF record\"))\nerr = try_next!(reader)\n\n@assert err isa PAF.ParserException\nerr2 = try_next!(reader)\n@assert err == err2","category":"page"},{"location":"","page":"Home","title":"Home","text":"The ParserException type contains the error type as an Enum, and the line where the exception occurred. These can be obtained with the .kind and .line properties.","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> err.line\n1\n\njulia> err.kind\nTooFewFields::Err = 0","category":"page"},{"location":"","page":"Home","title":"Home","text":"The precise value of this .kind object for any given error condition is subject to change across minor versions and new values may be introduced. This is because the same error may be detected in multiple different ways.","category":"page"},{"location":"#aux","page":"Home","title":"Auxiliary fields","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"PAFRecords may contain extra auxiliary fields at the end of the records, similar to SAM records. Any auxiliary data is stored in the PAFRecord, and lazily parsed and validated as they are accessed. This means that a PAFRecord may contain invalid auxiliary data.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The aux_data function constructs a lazy SAM.Auxiliary object from the package XAMAuxData.jl. The precise semantics of this Auxiliary type is a little complicated, and can be found in the documentation of XAMAuxData.jl. Here is a small example:","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> line = first(eachline(path_to_paf));\n\njulia> aux_string = join(split(line, '\\t')[13:end], '\\t')\n\"tp:A:P\\tcm:i:29990\\tdv:f:0.0000\\tkm:Z:some text here\"\n\njulia> record = parse(PAFRecord, line);\n\njulia> aux = aux_data(record);\n\njulia> isvalid(aux)\ntrue\n\njulia> aux[\"tp\"]\n'P': ASCII/Unicode U+0050 (category Lu: Letter, uppercase)\n\njulia> aux[\"km\"]\n\"some text here\"\n\njulia> haskey(aux, \"cm\")\ntrue\n\njulia> aux[\"AB\"] = 5.5;\n\njulia> haskey(aux, \"AB\")\ntrue","category":"page"},{"location":"#Misc-info","page":"Home","title":"Misc info","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The PAFReader cannot handle trailing whitespace, except trailing newlines at the end of the file. This is because trailing whitespace may be significant in some records, e.g. if it ends with an auxiliary field of the element type Z. A PAF record with trailing whitespace is considered invalid.","category":"page"},{"location":"#Reference","page":"Home","title":"Reference","text":"","category":"section"},{"location":"#PairwiseMappingFormat.PairwiseMappingFormat","page":"Home","title":"PairwiseMappingFormat.PairwiseMappingFormat","text":"module PairwiseMappingFormat\n\nParse files of the PairwisemAppingFormat (PAF) format.\n\n\n\n\n\n","category":"module"},{"location":"#PairwiseMappingFormat.PAFReader","page":"Home","title":"PairwiseMappingFormat.PAFReader","text":"PAFReader(io::IO; copy::Bool=true)\n\nConstruct a PAFReader, an iterator of PAFRecord read from io. Iterating this object returns a PAFRecord for each valid line of input, and throws a ParserException when an invalid record is found. For efficiency, the auxiliary fields are not validated until they are accessed.\n\nIf copy is false, the same record will be returned on each iteration, with its content being overwritten. This removes a few allocations per iteration, but may cause problems if records of old iterations are stored.\n\nExamples\n\njulia> reader = PAFReader(open(path_to_paf)); typeof(reader)\nPAFReader{IOStream}\n\njulia> typeof(first(reader))\nPAFRecord\n\njulia> PAFReader(open(path_to_paf)) do reader\n           for record in reader\n                println(record.qlen)\n           end\n       end\n301156\n299273\n288659\n\njulia> PAFReader(open(path_to_paf); copy=false) do reader\n           fst = first(reader)\n           all(reader) do record\n               record === fst\n           end\n       end\ntrue\n\nSee also: PAFRecord, try_next!\n\n\n\n\n\n","category":"type"},{"location":"#PairwiseMappingFormat.PAFRecord","page":"Home","title":"PairwiseMappingFormat.PAFRecord","text":"PAFRecord(buffer_size::Int)\n\nMutable type representing a single PAF line. The content of the record is accessed through its properties.\n\nExamples\n\njulia> record = PAFReader(first, open(path_to_paf));\n\njulia> record.qname\n\"query1\"\n\njulia> record.qlen\n301156\n\nSee also: PAFReader\n\nExtended help\n\nThe following properties may be used:\n\nqname::StringView. The query name, May be empty, and contain any bytes except \\t and \\n.\ntname::Union{StringView, Nothing}. Target name. Like qname, but is nothing if and only if the record is unmapped.\nqlen and tlen::Int, and gives the length of the query and target sequences, respectively. This must be > 0.\nqstart, qend, tstart and tend::Int, and give the starting and ending positions of the alignments on the query and target strand. These uses one-based, closed interval indexing as usual in Julia, but unlike the underlying PAF format. The ending positions are always >= the starting ones, and the ending positions are always <= the query/target lengths.\nmatches::Int gives the number of nucleotides / residues which match (i.e. are equal) in the alignment.\nalnlen::Int gives the length of the alignment\nmapq::Union{Int, Nothing} gives the mapping quality, or nothing if  this information is unavailable.\nis_rc::Union{Bool,Nothing} tells if the query and target strands are reverse-complement relative to each other. Is nothing if the record is unmapped.\n\n\n\n\n\n","category":"type"},{"location":"#PairwiseMappingFormat.aux_data","page":"Home","title":"PairwiseMappingFormat.aux_data","text":"aux_data(rec::Record) -> XAMAuxData.SAM.Auxiliary\n\nReturn a lazily evaluated and validated SAM.Auxiliary, which is an AbstractDict of the auxiliary fields at the end of the record. For more details about this object, read the documentation of the package XAMAuxData.jl.\n\nExamples\n\njulia> aux = aux_data(record);\n\njulia> length(aux)\n4\n\njulia> aux[\"cm\"]\n29990\n\njulia> aux[\"k1\"] = \"add a new aux string like this\";\n\njulia> haskey(aux, \"k1\")\ntrue\n\n\n\n\n\n","category":"function"},{"location":"#PairwiseMappingFormat.aln_identity","page":"Home","title":"PairwiseMappingFormat.aln_identity","text":"aln_identity(rec::Record) -> Float64\n\nReturn the nucleotide / residue identity, defined as the number of matches divided by the alignment length. This is a number between 0 and 1.\n\nExamples\n\njulia> aln_identity(record)\n1.0\n\nSee also: query_coverage, target_coverage\n\n\n\n\n\n","category":"function"},{"location":"#PairwiseMappingFormat.query_coverage","page":"Home","title":"PairwiseMappingFormat.query_coverage","text":"query_coverage(rec::Record) -> Float64\n\nCompute the fraction of the query covered by the alignment.\n\nExamples\n\njulia> query_coverage(record)\n0.9999535124653004\n\nSee also: target_coverage, aln_identity\n\n\n\n\n\n","category":"function"},{"location":"#PairwiseMappingFormat.target_coverage","page":"Home","title":"PairwiseMappingFormat.target_coverage","text":"target_coverage(rec::Record) -> Float64\n\nCompute the fraction of the target covered by the alignment.\n\nExamples\n\njulia> target_coverage(record)\n0.044934629307437725\n\nSee also: query_coverage, aln_identity\n\n\n\n\n\n","category":"function"},{"location":"#PairwiseMappingFormat.try_next!","page":"Home","title":"PairwiseMappingFormat.try_next!","text":"try_next!(reader::PAFReader) -> Union{Nothing, PAFRecord, ParserException}\n\nTry to read a record from the PAFReader and advance the reader. This may yield one of three options:\n\nIf the reader is empty, return nothing and do not advance the reader\nIf the next record is invalid, return (do not throw) a ParserException and do not advance the reader\nIf the next record is valid, return it as a PAFRecord and advance the reader\n\nEven if the reader itself is not advanced, it may still fill its internal buffer, advancing the IO object it wraps.\n\nExamples\n\njulia> reader = PAFReader(open(path_to_paf));\n\njulia> try_next!(reader) isa PAFRecord\ntrue\n\njulia> [try_next!(reader) for i in 1:2] isa Vector{PAFRecord}\ntrue\n\njulia> typeof([try_next!(reader) for i in 1:100])\nVector{Nothing} (alias for Array{Nothing, 1})\n\njulia> close(reader); reader = PAFReader(IOBuffer(\"bad data\"));\n\njulia> try_next!(reader) isa PAF.ParserException\ntrue\n\njulia> all(i -> try_next!(reader) isa PAF.ParserException, 1:100)\ntrue\n\n\n\n\n\n","category":"function"},{"location":"#PairwiseMappingFormat.is_mapped","page":"Home","title":"PairwiseMappingFormat.is_mapped","text":"is_mapped(x::PAFRecord) -> Bool\n\nCompute whether the PAFRecord is mapped. An unmapped record will have the properties is_rc and tname unavailable. The properties qname and qlen, and the auxiliary data of an unmapped record can be relied on, but the remaining properties contain arbitrary data. Note that some PAF parsers do not handle unmapped records correctly, so be wary when writing unmapped records.\n\nExamples\n\njulia> is_mapped(record)\ntrue\n\nSee also: PAFRecord\n\n\n\n\n\n","category":"function"},{"location":"#PairwiseMappingFormat.Errors","page":"Home","title":"PairwiseMappingFormat.Errors","text":"module Errors\n\nWrapper module used to contain the instances of error types, and not pollute the namespace of the package.\n\nExamples\n\njulia> print(PAF.Errors.InvalidZero)\nInvalidZero\n\nSee also: PairwiseMappingFormat.ParserException\n\n\n\n\n\n","category":"module"},{"location":"#PairwiseMappingFormat.try_parse","page":"Home","title":"PairwiseMappingFormat.try_parse","text":"try_parse(x) -> Union{PAFRecord, ParserException}\n\nTry parsing x into a PAFRecord. x may be any type that implements MemoryView, such as String or Vector{UInt8}.\n\nExamples\n\njulia> valid_line = open(readline, path_to_paf);\n\njulia> typeof(PAF.try_parse(valid_line))\nPAFRecord\n\njulia> typeof(PAF.try_parse(\"invalid string\"))\nPairwiseMappingFormat.ParserException\n\nSee also: PAFRecord, try_next!\n\n\n\n\n\n","category":"function"},{"location":"#PairwiseMappingFormat.ParserException","page":"Home","title":"PairwiseMappingFormat.ParserException","text":"ParserException\n\nThe exception type thrown by iterating PAFReader, or a failed parse of a PAFRecord. The functions try_parse and try_next! may return (not throw) values of this type. The line the error occurred may be accessed with the .line field. The error kind may be accessed with the .kind field.\n\nExamples\n\njulia> err = PAF.try_parse(\"abc\");\n\njulia> err.line\n1\n\njulia> print(err.kind)\nTooFewFields\n\n\n\n\n\n","category":"type"}]
}
