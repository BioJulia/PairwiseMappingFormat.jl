var documenterSearchIndex = {"docs":
[{"location":"","page":"Home","title":"Home","text":"CurrentModule = PairwiseMappingFormat\nDocTestSetup = quote\n    using PairwiseMappingFormat\n    using StringViews: StringView\n    path_to_paf = joinpath(pkgdir(PairwiseMappingFormat), \"test\", \"example.paf\")\n    record = PAFReader(first, open(path_to_paf))\n    const PAF = PairwiseMappingFormat\n    using PairwiseMappingFormat: try_parse\nend","category":"page"},{"location":"#PairwiseMappingFormat.jl","page":"Home","title":"PairwiseMappingFormat.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This package is for reading files of the PAF (Pairwise mApping Format) format, which is a simple tab-delimited format used by e.g. minimap2 and strobealign to store records representing pairwise alignment between biological sequences.","category":"page"},{"location":"#Reader","page":"Home","title":"Reader","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The PAFReader type wraps an IO, and is an iterator of PAFRecord objects:","category":"page"},{"location":"","page":"Home","title":"Home","text":"reader = PAFReader(open(path_to_paf))\nrecords = collect(reader)\nclose(reader)\n\n@assert isempty(reader)\n@assert typeof(records) == Vector{PAFRecord}","category":"page"},{"location":"","page":"Home","title":"Home","text":"Similar to the common open(path) do io-syntax in Julia, PAFReader takes an optional f::Function as a first argument, in which case it will apply f to the returned PAFReader object, and close the underlying io when f returns (or errors):","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> PAFReader(open(path_to_paf)) do reader\n           for record in reader\n               println(record.qlen)\n           end\n       end\n301156\n299273\n288659","category":"page"},{"location":"","page":"Home","title":"Home","text":"The PAFReader constructor takes an optional keyword copy, which defaults to true. If it is false, the record will iterate the same PAFRecord object, overwriting it in-place. This reduces allocations and gives a slight speed increase, but may result in bugs if records, or references of records of previous iterations are stored and unexpectedly overwritten:","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> records = PAFReader(collect, open(path_to_paf); copy=false);\n\njulia> println(map(i -> i.qlen, records)) # NB: All the same record!\n[288659, 288659, 288659]","category":"page"},{"location":"","page":"Home","title":"Home","text":"At the moments, readers do not support seeking.","category":"page"},{"location":"#Record","page":"Home","title":"Record","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The mutable PAFRecord object represents a single line in a PAF file. The individual columns of the PAF line is obtained by accessing properties of the records:","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> record = PAFReader(first, open(path_to_paf));\n\njulia> println(record.qname)\nquery1\n\njulia> println(record.qlen)\n301156\n\njulia> println(record.mapq)\n0","category":"page"},{"location":"","page":"Home","title":"Home","text":"Note that Base.getproperty is overloaded for PAFRecord, so the properties are public and stable across major versions, but may not reflect the actual underlying fields as they are stored in the PAFRecord.","category":"page"},{"location":"","page":"Home","title":"Home","text":"A description of the properties of PAFRecords can be found in the docstring of PAFRecord, but here is a list of them:","category":"page"},{"location":"","page":"Home","title":"Home","text":"properties = [\n    (:qname,   StringView),\n    (:qlen,    Int),\n    (:qstart,  Int),\n    (:qend,    Int),\n    (:tname,   StringView),\n    (:tlen,    Int),\n    (:tstart,  Int),\n    (:tend,    Int),\n    (:matches, Int),\n    (:alnlen,  Int),\n    (:mapq,    Union{Int, Nothing}),\n    (:is_rc,   Bool),\n]\n\n@assert length(propertynames(record)) == length(properties)\n\nfor (property, type) in properties\n    @assert getproperty(record, property) isa type\nend","category":"page"},{"location":"","page":"Home","title":"Home","text":"The PAF format does not contain fields for alignment identity, query coverage or target coverage. However, these can be approximated with the functions aln_identity, query_coverage and query_coverage.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Besides being iterated from PAFReader, records can also be created by parsing from a bytes-like object such as a String:","category":"page"},{"location":"","page":"Home","title":"Home","text":"data = \"contig_11\\t288659\\t27\\t288653\\t+\\tCP004047.1\\t6701780\\t5027225\\t5315851\\t288618\\t288626\\t0\\ttp:A:P\\tcm:i:28871\\ts1:i:288618\\ts2:i:288618\\tdv:f:0.0000\\trl:i:57\"\n\nrecord = parse(PAFRecord, data)\n@assert record isa PAFRecord","category":"page"},{"location":"","page":"Home","title":"Home","text":"Rarely, PAF records are unmapped. An unmapped record contain the query id, the query length, and any auxiliary fields. The target name and the strand of an unmapped return is nothing. You can check if a record is mapped or unmapped with the function is_mapped:","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> unmapped = parse(PAFRecord, \"myquery\\t5032251\\t9\\t11\\t*\\t*\\t5\\t2\\t1\\t7\\t4\\t0\");\n\njulia> @assert !is_mapped(unmapped)\n\njulia> println(unmapped.qname)\nmyquery\n\njulia> println(unmapped.qlen)\n5032251\n\njulia> @assert isnothing(unmapped.tname)\n\njulia> # The strand is given by is_rc, and is nothing for unmapped records\n       @assert isnothing(unmapped.is_rc)","category":"page"},{"location":"","page":"Home","title":"Home","text":"All other properties of unmapped records may contain arbitrary data, and should not be relied on. For this reason, the functions target_coverage, query_coverage and aln_identity may give nonsense answers for unmapped records:","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> # Note! These results are arbitrary and not guaranteed to be stable\n       # across minor releases of this package\n       println(target_coverage(unmapped))\nInf\n\njulia> println(query_coverage(unmapped))\n1.9871822768776836e-7\n\njulia> println(aln_identity(unmapped))\nNaN","category":"page"},{"location":"#Low-level-interface","page":"Home","title":"Low-level interface","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Iterating PAFReaders, and the parse function will throw a PairwiseMappingFormat.ParserException if the data is invalid:","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> parse(PAFRecord, \"not a PAF line\")\nERROR: Error when parsing PAF record on line 1, near byte number 14 in line: Not enough tab-separated fields. Each line must have at least 12 fields\n[...]","category":"page"},{"location":"","page":"Home","title":"Home","text":"In some circuomstances, throwing exceptions may not be acceptable, and so PairwiseMappingFormat.jl provide functionality for returning errors as values. These values can then be checked to programmatically handle error states.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The public, unexported try_parse function can be used instead of Base.parse. It either returns a valid PAFRecord, or else returns the ParserException, but does not throw the exception:","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> const PAF = PairwiseMappingFormat;\n\njulia> println(PAF.try_parse(\"not a PAF line\"))\nPairwiseMappingFormat.ParserException(PairwiseMappingFormat.Errors.TooFewFields, 14, 1)","category":"page"},{"location":"","page":"Home","title":"Home","text":"Similarly, the next record of a PAFReader may be obtained with the unexported try_next! function. This function will either:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Return nothing if the reader has no more records\nReturn a ParserException if the next record is invalid\nReturn a PAFRecord if there is another valid record. Only in this case it will advance the position of the reader.","category":"page"},{"location":"","page":"Home","title":"Home","text":"In other words, if a call to try_next! returns nothing or a ParserException, any future calls will return the same value forever:","category":"page"},{"location":"","page":"Home","title":"Home","text":"reader = PAFReader(open(path_to_paf))\n\n# Emits `PAFRecord` for valid records\nrecords = [try_next!(reader) for i in 1:3]\n@assert records isa Vector{PAFRecord}\n\n# Indefinitely emits `nothing` once the reader is empty\nnothings = [try_next!(reader) for i in 1:10]\n@assert nothings isa Vector{Nothing}\n\nclose(reader)\n\nreader = PAFReader(IOBuffer(\"not a PAF record\"))\nerr = try_next!(reader)\n\n@assert err isa PAF.ParserException\nerr2 = try_next!(reader)\n@assert err == err2","category":"page"},{"location":"","page":"Home","title":"Home","text":"The ParserException type contains the error type as an Enum, and the line where the exception occurred. These can be obtained with the .kind and .line properties.","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> err.line\n1\n\njulia> err.kind\nTooFewFields::Err = 0","category":"page"},{"location":"","page":"Home","title":"Home","text":"The precise value of this .kind object for any given error condition is subject to change across minor versions and new values may be introduced. This is because the same error may be detected in multiple different ways.","category":"page"},{"location":"#aux","page":"Home","title":"Auxiliary fields","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"PAFRecords may contain extra auxiliary fields at the end of the records, similar to SAM records. Any auxiliary data is stored in the PAFRecord, and lazily parsed and validated as they are accessed. This means that a PAFRecord may contain invalid auxiliary data.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The aux_data function constructs a lazy SAM.Auxiliary object from the package XAMAuxData.jl. The precise semantics of this Auxiliary type is a little complicated, and can be found in the documentation of XAMAuxData.jl. Here is a small example:","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> line = first(eachline(path_to_paf));\n\njulia> aux_string = join(split(line, '\\t')[13:end], '\\t')\n\"tp:A:P\\tcm:i:29990\\tdv:f:0.0000\\tkm:Z:some text here\"\n\njulia> record = parse(PAFRecord, line);\n\njulia> aux = aux_data(record);\n\njulia> isvalid(aux)\ntrue\n\njulia> aux[\"tp\"]\n'P': ASCII/Unicode U+0050 (category Lu: Letter, uppercase)\n\njulia> aux[\"km\"]\n\"some text here\"\n\njulia> haskey(aux, \"cm\")\ntrue\n\njulia> aux[\"AB\"] = 5.5;\n\njulia> haskey(aux, \"AB\")\ntrue","category":"page"},{"location":"#Misc-info","page":"Home","title":"Misc info","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The PAFReader cannot handle trailing whitespace, except trailing newlines at the end of the file. This is because trailing whitespace may be significant in some records, e.g. if it ends with an auxiliary field of the element type Z. A PAF record with trailing whitespace is considered invalid.","category":"page"},{"location":"#Reference","page":"Home","title":"Reference","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"PAFReader\nPAFRecord\naux_data\naln_identity\nquery_coverage\ntarget_coverage\ntry_next!\nis_mapped\nPairwiseMappingFormat.try_parse\nPairwiseMappingFormat.ParserException","category":"page"},{"location":"#PairwiseMappingFormat.PAFReader","page":"Home","title":"PairwiseMappingFormat.PAFReader","text":"PAFReader(io::IO; copy::Bool=true)\n\nConstruct a PAFReader, an iterator of PAFRecord read from io. Iterating this object returns a PAFRecord for each valid line of input, and throws a ParserException when an invalid record is found. For efficiency, the auxiliary fields are not validated until they are accessed.\n\nIf copy is false, the same record will be returned on each iteration, with its content being overwritten. This removes a few allocations per iteration, but may cause problems if records of old iterations are stored.\n\nExamples\n\njulia> reader = PAFReader(open(path_to_paf)); typeof(reader)\nPAFReader{IOStream}\n\njulia> typeof(first(reader))\nPAFRecord\n\njulia> PAFReader(open(path_to_paf)) do reader\n           for record in reader\n                println(record.qlen)\n           end\n       end\n301156\n299273\n288659\n\njulia> PAFReader(open(path_to_paf); copy=false) do reader\n           fst = first(reader)\n           all(reader) do record\n               record === fst\n           end\n       end\ntrue\n\nSee also: PAFRecord, try_next!\n\n\n\n\n\n","category":"type"},{"location":"#PairwiseMappingFormat.PAFRecord","page":"Home","title":"PairwiseMappingFormat.PAFRecord","text":"PAFRecord(buffer_size::Int)\n\nMutable type representing a single PAF line. The content of the record is accessed through its properties.\n\nExamples\n\njulia> record = PAFReader(first, open(path_to_paf));\n\njulia> record.qname\n\"query1\"\n\njulia> record.qlen\n301156\n\nSee also: PAFReader\n\nExtended help\n\nThe following properties may be used:\n\nqname::StringView. The query name, May be empty, and contain any bytes except \\t and \\n.\ntname::Union{StringView, Nothing}. Target name. Like qname, but is nothing if and only if the record is unmapped.\nqlen and tlen::Int, and gives the length of the query and target sequences, respectively. This must be > 0.\nqstart, qend, tstart and tend::Int, and give the starting and ending positions of the alignments on the query and target strand. These uses one-based, closed interval indexing as usual in Julia, but unlike the underlying PAF format. The ending positions are always >= the starting ones, and the ending positions are always <= the query/target lengths.\nmatches::Int gives the number of nucleotides / residues which match (i.e. are equal) in the alignment.\nalnlen::Int gives the length of the alignment\nmapq::Union{Int, Nothing} gives the mapping quality, or nothing if  this information is unavailable.\nis_rc::Union{Bool,Nothing} tells if the query and target strands are reverse-complement relative to each other. Is nothing if the record is unmapped.\n\n\n\n\n\n","category":"type"},{"location":"#PairwiseMappingFormat.aux_data","page":"Home","title":"PairwiseMappingFormat.aux_data","text":"aux_data(rec::Record) -> XAMAuxData.SAM.Auxiliary\n\nReturn a lazily evaluated and validated SAM.Auxiliary, which is an AbstractDict of the auxiliary fields at the end of the record. For more details about this object, read the documentation of the package XAMAuxData.jl.\n\nExamples\n\njulia> aux = aux_data(record);\n\njulia> length(aux)\n4\n\njulia> aux[\"cm\"]\n29990\n\njulia> aux[\"k1\"] = \"add a new aux string like this\";\n\njulia> haskey(aux, \"k1\")\ntrue\n\n\n\n\n\n","category":"function"},{"location":"#PairwiseMappingFormat.aln_identity","page":"Home","title":"PairwiseMappingFormat.aln_identity","text":"aln_identity(rec::Record) -> Float64\n\nReturn the nucleotide / residue identity, defined as the number of matches divided by the alignment length. This is a number between 0 and 1.\n\nExamples\n\njulia> aln_identity(record)\n1.0\n\nSee also: query_coverage, target_coverage\n\n\n\n\n\n","category":"function"},{"location":"#PairwiseMappingFormat.query_coverage","page":"Home","title":"PairwiseMappingFormat.query_coverage","text":"query_coverage(rec::Record) -> Float64\n\nCompute the fraction of the query covered by the alignment.\n\nExamples\n\njulia> query_coverage(record)\n0.9999535124653004\n\nSee also: target_coverage, aln_identity\n\n\n\n\n\n","category":"function"},{"location":"#PairwiseMappingFormat.target_coverage","page":"Home","title":"PairwiseMappingFormat.target_coverage","text":"target_coverage(rec::Record) -> Float64\n\nCompute the fraction of the target covered by the alignment.\n\nExamples\n\njulia> target_coverage(record)\n0.044934629307437725\n\nSee also: query_coverage, aln_identity\n\n\n\n\n\n","category":"function"},{"location":"#PairwiseMappingFormat.try_next!","page":"Home","title":"PairwiseMappingFormat.try_next!","text":"try_next!(reader::PAFReader) -> Union{Nothing, PAFRecord, ParserException}\n\nTry to read a record from the PAFReader and advance the reader. This may yield one of three options:\n\nIf the reader is empty, return nothing and do not advance the reader\nIf the next record is invalid, return (do not throw) a ParserException and do not advance the reader\nIf the next record is valid, return it as a PAFRecord and advance the reader\n\nEven if the reader itself is not advanced, it may still fill its internal buffer, advancing the IO object it wraps.\n\nExamples\n\njulia> reader = PAFReader(open(path_to_paf));\n\njulia> try_next!(reader) isa PAFRecord\ntrue\n\njulia> [try_next!(reader) for i in 1:2] isa Vector{PAFRecord}\ntrue\n\njulia> typeof([try_next!(reader) for i in 1:100])\nVector{Nothing} (alias for Array{Nothing, 1})\n\njulia> close(reader); reader = PAFReader(IOBuffer(\"bad data\"));\n\njulia> try_next!(reader) isa PAF.ParserException\ntrue\n\njulia> all(i -> try_next!(reader) isa PAF.ParserException, 1:100)\ntrue\n\n\n\n\n\n","category":"function"},{"location":"#PairwiseMappingFormat.is_mapped","page":"Home","title":"PairwiseMappingFormat.is_mapped","text":"is_mapped(x::PAFRecord) -> Bool\n\nCompute whether the PAFRecord is mapped. An unmapped record will have the properties is_rc and tname unavailable. The properties qname and qlen, and the auxiliary data of an unmapped record can be relied on, but the remaining properties contain arbitrary data. Note that some PAF parsers do not handle unmapped records correctly, so be wary when writing unmapped records.\n\nExamples\n\njulia> is_mapped(record)\ntrue\n\nSee also: PAFRecord\n\n\n\n\n\n","category":"function"},{"location":"#PairwiseMappingFormat.try_parse","page":"Home","title":"PairwiseMappingFormat.try_parse","text":"try_parse(x) -> Union{PAFRecord, ParserException}\n\nTry parsing x into a PAFRecord. x may be any type that implements MemoryView, such as String or Vector{UInt8}.\n\nExamples\n\njulia> valid_line = open(readline, path_to_paf);\n\njulia> typeof(PAF.try_parse(valid_line))\nPAFRecord\n\njulia> typeof(PAF.try_parse(\"invalid string\"))\nPairwiseMappingFormat.ParserException\n\nSee also: PAFRecord, try_next!\n\n\n\n\n\n","category":"function"},{"location":"#PairwiseMappingFormat.ParserException","page":"Home","title":"PairwiseMappingFormat.ParserException","text":"ParserException\n\nThe exception type thrown by iterating PAFReader, or a failed parse of a PAFRecord. The functions try_parse and try_next! may return (not throw) values of this type. The line the error occurred may be accessed with the .line field. The error kind may be accessed with the .kind field.\n\nExamples\n\njulia> err = PAF.try_parse(\"abc\");\n\njulia> err.line\n1\n\njulia> print(err.kind)\nTooFewFields\n\n\n\n\n\n","category":"type"}]
}
